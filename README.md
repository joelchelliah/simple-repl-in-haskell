# simple-repl-in-haskell
> How to make you very own REPL in Haskell

This is a simple step-by-step tutorial on how to create a very simple **REPL** in Haskell. 

Prior knowledge or experience with Haskell is not required to grasp the basic principles of this walkthrough, 
although some basic understanding of functional programming will probably make it a lot easier to understand 
the example code.

## What's a REPL
REPL stands for Read-Eval-Print-Loop, and as the name implies, its job is to:
  1. **Read** the given input, and parse it into a data structure that can be evaluated.
  2. **Evaluate** the parsed expression, based on some set of rules or logic.
  3. **Print** the result of the evaluated epxression.
  4. **Repeat** (loop) until signaled to stop.

REPLs are most commonly associated with programming languages, where they are used as an interactive 
shell for interpreting the code written that language. Most languages often come with such REPLs already bundled 
into their toolkit (e.g. Ruby's [IRB](https://en.wikipedia.org/wiki/Interactive_Ruby_Shell), or Haskell's [GHCi](https://wiki.haskell.org/GHC/GHCi)). 
These days, there's also an evergrowing number of online REPLs that support several different languages, 
such as [repl.it](https://repl.it/site/about). 

In these cases, the **read** and **evaluate** parts are focused around interpreting the input 
based on the language that provides the REPL. However, stricly speaking, a REPL doesn't necessarily have 
to be connected to a fully fleshed out programming language (or any language at all). Although that is its
most common use case, one can argue that a REPL can pretty much be anything you want it to be, as long as 
it can **read**, **evaluate** and **print** whatever you throw at it in a repeating **loop**. 

So by that definition, let's get started on creating our very own, very simple, REPL!


## How to make a REPL
> Todo


## Playing around with evaluators
> Todo


## Additional functionality
> Todo
